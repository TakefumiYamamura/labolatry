result <- lm(question ~ lsd)
result.plot <- predict(result, interval = "confidence")
matplot(lsd, result.plot, xlab="lsd", ylab = "question", type = "l")
wing <- c(10.4, 10.8, 11.1, 10.2, 10.3, 10.2, 10.7, 10.5, 10.8, 11.2, 10.6, 11.4)
tail <- c(7.4, 7.6, 7.9, 7.2, 7.4, 7.1, 7.4, 7.2, 7.8, 7.7, 7.8, 8.3)
summary(lm(wing ~ tail))
cor.test(wing, tail)
r <- cor(wing, tail)
n <- 12
t <- r*sqrt((n-2)/(1-r^2))
df <- n-2
prob <-2*pt(t,df, lower=F)
c("t" = t, "d.f."=df, "P value" = prob)
wing <- c(10.4, 10.8, 11.1, 10.2, 10.3, 10.2, 10.7, 10.5, 10.8, 11.2, 10.6, 11.4)
tail <- c(7.4, 7.6, 7.9, 7.2, 7.4, 7.1, 7.4, 7.2, 7.8, 7.7, 7.8, 8.3)
summary(lm(wing ~ tail))
cor.test(wing, tail)
r <- cor(wing, tail)
n <- 12
t <- r*sqrt((n-2)/(1-r^2))
df <- n-2
prob <-2*pt(t,df, lower=F)
c("t" = t, "d.f."=df, "P value" = prob)
age <- c(3.0, 4.0, 5.0, 6.0, 8.0, 9.0, 10.0, 11.0, 12.0, 14.0, 15.0, 16.0, 17.0)
wing <- c(1.4, 1.5, 2.2, 2.4, 3.1, 3.2, 3.2, 3.9, 4.1, 4.7, 4.5, 5.2, 5.0)
result1 <- lm(wing ~ age)
summary(result1)
mydata <- data.frame(wing = as.vector(wing), age = as.vector(age))
summary(aov(wing ~ age, data = mydata))
# X11()
result1_plot <- predict(result1, interval = "confidence")
matplot(age, result1_plot, xlab="age(days)", ylab = "wing length (mm)", type = "l")
parentes <- c(1,2,4,5,3,2,3,1,5,4,4,2)
chid <- c(3,4,4,5,5,3,4,3,6,6,5,5)
result <- lm(age~parents)
summary(result)
parentes <- c(1,2,4,5,3,2,3,1,5,4,4,2)
children <- c(3,4,4,5,5,3,4,3,6,6,5,5)
result <- lm(children ~ parents)
summary(result)
parentes <- c(1,2,4,5,3,2,3,1,5,4,4,2)
children <- c(3,4,4,5,5,3,4,3,6,6,5,5)
result <- lm(children ~ parents)
parents <- c(1,2,4,5,3,2,3,1,5,4,4,2)
children <- c(3,4,4,5,5,3,4,3,6,6,5,5)
result <- lm(children ~ parents)
summary(result)
parents <- c(1,2,4,5,3,2,3,1,5,4,4,2)
children <- c(3,4,4,5,5,3,4,3,6,6,5,5)
result <- lm(children ~ parents)
summary(result)
result_plot <- predict(result1, interval = "confidence")
matplot(parents, result_plot, xlab="両親の結婚年数", ylab = "被験者の結婚年数", type = "l")
parents <- c(1,2,4,5,3,2,3,1,5,4,4,2)
children <- c(3,4,4,5,5,3,4,3,6,6,5,5)
result <- lm(children ~ parents)
summary(result)
result_plot <- predict(result, interval = "confidence")
matplot(parents, result_plot, xlab="両親の結婚年数", ylab = "被験者の結婚年数", type = "l")
parents <- c(1,2,4,5,3,2,3,1,5,4,4,2)
children <- c(3,4,4,5,5,3,4,3,6,6,5,5)
result <- lm(children ~ parents)
summary(result)
result_plot <- predict(result, interval = "confidence")
matplot(parents, result_plot, xlab="duration of marriage in parents", ylab = "duration of marriage in children", type = "l")
result
result_plot
parents <- c(1,2,4,5,3,2,3,1,5,4,4,2)
children <- c(3,4,4,5,5,3,4,3,6,6,5,5)
result <- lm(children ~ parents)
summary(result)
result_plot
order(result_plot$fit)
order(result_plot,fit)
order(result_plot)
result_plot
result_plot
parents <- c(1,2,4,5,3,2,3,1,5,4,4,2)
children <- c(3,4,4,5,5,3,4,3,6,6,5,5)
result <- lm(children ~ parents)
summary(result)
result
parents <- c(1,2,4,5,3,2,3,1,5,4,4,2)
children <- c(3,4,4,5,5,3,4,3,6,6,5,5)
mydata <- data.frame(parents = as.vector(parents), children = as.vector(children))
mydata
order(mydata$parents)
mydata[order(mydata$parents)]
mydata[order(mydata$parents),]
sorted_data <- mydata[order(mydata$parents),]
sorted_data
sorted_data$parents
parents <- c(1,2,4,5,3,2,3,1,5,4,4,2)
children <- c(3,4,4,5,5,3,4,3,6,6,5,5)
mydata <- data.frame(parents = as.vector(parents), children = as.vector(children))
sorted_data <- mydata[order(mydata$parents),]
result <- lm(sorted_data$children ~ sorted_data$parents)
summary(result)
result_plot <- predict(result, interval = "confidence")
matplot(sorted_data$parents, result_plot, xlab="duration of marriage in parents", ylab = "duration of marriage in children", type = "l")
make_name <- function(dir, i) {
source('~/labolatory/plot/make_table2.r')
make_name <- function(dir, i) {
name1 <- paste(dir,"/func", sep="")
name2 <- paste(name1, i, sep="")
name3 <- paste(name2,".csv", sep="")
return(name3)
}
dir_name <- c("csvs_length_shade_with_archive_D10","csvs_length_shade_wo_archive_D10","csvs_length_de_with_archive_D10","csvs_length_de_wo_archive_D10")
for (i in 1:15) {
name1 <- make_name(dir_name[1], i)
data1 <- read.csv(name1)
name2 <- make_name(dir_name[2], i)
data2 <- read.csv(name2)
generation_number <- 1:5998
average_distance_to_centroid <- data.frame(csvs_length_shade_with_archive_D10=data1[,1], csvs_length_shade_wo_archive_D10=data2[,1])
average_distance_to_centroid_log1 <- c()
for (j in data1[,1]) {
if (j > 0.000000001){
# print(j)
average_distance_to_centroid_log1 <- append(average_distance_to_centroid_log1,log10(as.numeric(j)))
} else {
average_distance_to_centroid_log1 <- append(average_distance_to_centroid_log1, 1 )
}
}
average_distance_to_centroid_log2 <- c()
for (j in data2[,1]) {
if (j > 0.000000001){
average_distance_to_centroid_log2 <- append(average_distance_to_centroid_log2,log10(as.numeric(j)))
} else {
average_distance_to_centroid_log2 <- append(average_distance_to_centroid_log2, 1 )
}
}
average_distance_to_centroid <- data.frame(csvs_length_shade_with_archive_D10=average_distance_to_centroid_log1, csvs_length_shade_wo_archive_D10=average_distance_to_centroid_log2)
# plot(x, data[,1],type='l' )
type <- c("shade_w/a","shade_wo/a")
cols <- c("red", "blue")
#legend("topleft", legend = type, lty = 1, col = cols)
matplot(generation_number, average_distance_to_centroid, type='l', col = cols)
}
for (i in 1:15) {
name1 <- make_name(dir_name[3], i)
data1 <- read.csv(name1)
name2 <- make_name(dir_name[4], i)
data2 <- read.csv(name2)
# d1 <- data1[,1]
# for (j in 1:length(d1)) {d1[j] <- log10(d1[j])}
# d12 <- data2[,1]
# for (j in 1:length(d2)) {d2[j] <- log10(d2[j])}
generation_number <- 1:1998
average_distance_to_centroid <- data.frame(csvs_length_shade_with_archive_D10=data1[,1], csvs_length_shade_wo_archive_D10=data2[,1])
average_distance_to_centroid_log1 <- c()
for (j in data1[,1]) {
# if (j > 0.000000001){
# print(j)
average_distance_to_centroid_log1 <- append(average_distance_to_centroid_log1,log10(as.numeric(j)))
# } else {
#   average_distance_to_centroid_log1 <- append(average_distance_to_centroid_log1, 1 )
# }
}
average_distance_to_centroid_log2 <- c()
for (j in data2[,1]) {
if (j > 0.000000001){
average_distance_to_centroid_log2 <- append(average_distance_to_centroid_log2,log10(as.numeric(j)))
} else {
average_distance_to_centroid_log2 <- append(average_distance_to_centroid_log2, 1 )
}
}
average_distance_to_centroid <- data.frame(csvs_length_shade_with_archive_D10=average_distance_to_centroid_log1, csvs_length_shade_wo_archive_D10=average_distance_to_centroid_log2)
# plot(x, data[,1],type='l' )
type <- c("shade_w/a","shade_wo/a")
cols <- c("red", "blue")
#legend("topleft", legend = type, lty = 1, col = cols)
matplot(generation_number, average_distance_to_centroid, type='l')
}
# library(exactRankTests)
# library(knitr)
# library(xtable)
dim <- c(2,10,30,50,100)
# pop <- 30
populations <- c(10, 30, 50)
for (mu in 1:3){
for (i in 1:5) {
file_name <- paste("sphere_fitness/pop", populations[mu], "dim" , sep = "")
file_name = paste(file_name, dim[i], ".csv" , sep = "")
x <- read.csv(file_name, header = FALSE)
type <- unique(x[, 1])
print(type)
# x[,-1] <- log(x[,-1], 10)
# x[,-1] <- x[,-1][sapply(x[,-1],is.numeric)]
# for (j in 1:ncol(x)) {
#   x[,j] <- ifelse(x[,j] == 0)
#     ,NA,x[,j])
# }
x[,-1] <- log(x[,-1][sapply(x[,-1],is.numeric), 10)
xaxis <- 1:ncol(x[, -1])          # x 軸座標を設定
cols <- c("red", "blue") # PF を赤色、C を青色、G を緑色
# 準備
# print( range(x[,-1][sapply(x[,-1],is.numeric)],na.rm = TRUE))
plot(0, 0, type = "n", xlim = range(xaxis), ylim = range(x[,-1][sapply(x[,-1],is.numeric)],na.rm = TRUE), xlab = "generation number", ylab = "std in fitness")
# 平均値と標準偏差を計算して、書き加える
# type <- unique(x[, 1])             # DEの種類を取得
# type <- x[,1]
# y <- x[c(1,ncol(x))]
# de_with<-y[y[, 1] == type[1], -1]
# de_wo <-y[y[, 1] == type[2], -1]
# shade_with<-y[y[, 1] == type[3], -1]
# shade_wo<-y[y[, 1] == type[4], -1]
# result1 <- wilcox.exact(de_with, de_wo,paired=F)
# result2 <- wilcox.exact(shade_with, shade_wo, paired=F)
# if (result1$p.value > 0.05){
#   print("有意じゃない")
# }
# if (result2$p.value > 0.05){
#   print("有意じゃない関数")
# }
for (k in 1:length(type)) {
m <- apply(x[x[, 1] == type[k], -1], 2, mean)
s <- apply(x[x[, 1] == type[k], -1], 2, sd)
# print(m)
lines(xaxis, m, col = cols[k])
xaxis_n <- c()
m_n <- c()
s_n <- c()
for (j in 1:length(xaxis)) {
if (j %% 100 == 0){
xaxis_n <- append(xaxis_n, xaxis[j])
m_n <- append(m_n, m[j])
s_n <- append(s_n, s[j])
}
}
arrows(xaxis_n, m_n + s_n, xaxis_n, m_n - s_n, angle = 90, length = 0.05, col = cols[k])
arrows(xaxis_n, m_n - s_n, xaxis_n, m_n + s_n, angle = 90, length = 0.05, col = cols[k])
}
eps <- paste("eps/P", populations[mu], "fitD", sep="")
out_put_file_name <- paste(eps, dim[i], ".eps" , sep = "")
# dev.copy2eps(file = "myFigure.eps")
dev.copy2eps(file = out_put_file_name)
# pictex(file = "plot_test.tex")
# グラフに凡例を書き入れる
# legend("topleft", legend = type, pch = 1, lty = 1, col = cols)
}
}
setwd("~/labolatory/plot")
# library(exactRankTests)
# library(knitr)
# library(xtable)
dim <- c(2,10,30,50,100)
# pop <- 30
populations <- c(10, 30, 50)
for (mu in 1:3){
for (i in 1:5) {
file_name <- paste("sphere_fitness/pop", populations[mu], "dim" , sep = "")
file_name = paste(file_name, dim[i], ".csv" , sep = "")
x <- read.csv(file_name, header = FALSE)
type <- unique(x[, 1])
print(type)
# x[,-1] <- log(x[,-1], 10)
# x[,-1] <- x[,-1][sapply(x[,-1],is.numeric)]
# for (j in 1:ncol(x)) {
#   x[,j] <- ifelse(x[,j] == 0)
#     ,NA,x[,j])
# }
x[,-1] <- log(x[,-1][sapply(x[,-1],is.numeric), 10)
xaxis <- 1:ncol(x[, -1])          # x 軸座標を設定
cols <- c("red", "blue") # PF を赤色、C を青色、G を緑色
# 準備
# print( range(x[,-1][sapply(x[,-1],is.numeric)],na.rm = TRUE))
plot(0, 0, type = "n", xlim = range(xaxis), ylim = range(x[,-1][sapply(x[,-1],is.numeric)],na.rm = TRUE), xlab = "generation number", ylab = "std in fitness")
# 平均値と標準偏差を計算して、書き加える
# type <- unique(x[, 1])             # DEの種類を取得
# type <- x[,1]
# y <- x[c(1,ncol(x))]
# de_with<-y[y[, 1] == type[1], -1]
# de_wo <-y[y[, 1] == type[2], -1]
# shade_with<-y[y[, 1] == type[3], -1]
# shade_wo<-y[y[, 1] == type[4], -1]
# result1 <- wilcox.exact(de_with, de_wo,paired=F)
# result2 <- wilcox.exact(shade_with, shade_wo, paired=F)
# if (result1$p.value > 0.05){
#   print("有意じゃない")
# }
# if (result2$p.value > 0.05){
#   print("有意じゃない関数")
# }
for (k in 1:length(type)) {
m <- apply(x[x[, 1] == type[k], -1], 2, mean)
s <- apply(x[x[, 1] == type[k], -1], 2, sd)
# print(m)
lines(xaxis, m, col = cols[k])
xaxis_n <- c()
m_n <- c()
s_n <- c()
for (j in 1:length(xaxis)) {
if (j %% 100 == 0){
xaxis_n <- append(xaxis_n, xaxis[j])
m_n <- append(m_n, m[j])
s_n <- append(s_n, s[j])
}
}
arrows(xaxis_n, m_n + s_n, xaxis_n, m_n - s_n, angle = 90, length = 0.05, col = cols[k])
arrows(xaxis_n, m_n - s_n, xaxis_n, m_n + s_n, angle = 90, length = 0.05, col = cols[k])
}
eps <- paste("eps/P", populations[mu], "fitD", sep="")
out_put_file_name <- paste(eps, dim[i], ".eps" , sep = "")
# dev.copy2eps(file = "myFigure.eps")
dev.copy2eps(file = out_put_file_name)
# pictex(file = "plot_test.tex")
# グラフに凡例を書き入れる
# legend("topleft", legend = type, pch = 1, lty = 1, col = cols)
}
}
# library(exactRankTests)
# library(knitr)
# library(xtable)
dim <- c(2,10,30,50,100)
# pop <- 30
populations <- c(10, 30, 50)
for (mu in 1:3){
for (i in 1:5) {
file_name <- paste("sphere_fitness/pop", populations[mu], "dim" , sep = "")
file_name = paste(file_name, dim[i], ".csv" , sep = "")
x <- read.csv(file_name, header = FALSE)
type <- unique(x[,1])
print(type)
# x[,-1] <- log(x[,-1], 10)
# x[,-1] <- x[,-1][sapply(x[,-1],is.numeric)]
# for (j in 1:ncol(x)) {
#   x[,j] <- ifelse(x[,j] == 0)
#     ,NA,x[,j])
# }
# x[,-1] <- log(x[,-1][sapply(x[,-1],is.numeric), 10)
xaxis <- 1:ncol(x[, -1])          # x 軸座標を設定
cols <- c("red", "blue") # PF を赤色、C を青色、G を緑色
# 準備
# print( range(x[,-1][sapply(x[,-1],is.numeric)],na.rm = TRUE))
plot(0, 0, type = "n", xlim = range(xaxis), ylim = range(x[,-1][sapply(x[,-1],is.numeric)],na.rm = TRUE), xlab = "generation number", ylab = "std in fitness")
# 平均値と標準偏差を計算して、書き加える
# type <- unique(x[, 1])             # DEの種類を取得
# type <- x[,1]
# y <- x[c(1,ncol(x))]
# de_with<-y[y[, 1] == type[1], -1]
# de_wo <-y[y[, 1] == type[2], -1]
# shade_with<-y[y[, 1] == type[3], -1]
# shade_wo<-y[y[, 1] == type[4], -1]
# result1 <- wilcox.exact(de_with, de_wo,paired=F)
# result2 <- wilcox.exact(shade_with, shade_wo, paired=F)
# if (result1$p.value > 0.05){
#   print("有意じゃない")
# }
# if (result2$p.value > 0.05){
#   print("有意じゃない関数")
# }
for (k in 1:length(type)) {
m <- apply(x[x[, 1] == type[k], -1], 2, mean)
s <- apply(x[x[, 1] == type[k], -1], 2, sd)
# print(m)
lines(xaxis, m, col = cols[k])
xaxis_n <- c()
m_n <- c()
s_n <- c()
for (j in 1:length(xaxis)) {
if (j %% 100 == 0){
xaxis_n <- append(xaxis_n, xaxis[j])
m_n <- append(m_n, m[j])
s_n <- append(s_n, s[j])
}
}
arrows(xaxis_n, m_n + s_n, xaxis_n, m_n - s_n, angle = 90, length = 0.05, col = cols[k])
arrows(xaxis_n, m_n - s_n, xaxis_n, m_n + s_n, angle = 90, length = 0.05, col = cols[k])
}
eps <- paste("eps/P", populations[mu], "fitD", sep="")
out_put_file_name <- paste(eps, dim[i], ".eps" , sep = "")
# dev.copy2eps(file = "myFigure.eps")
dev.copy2eps(file = out_put_file_name)
# pictex(file = "plot_test.tex")
# グラフに凡例を書き入れる
# legend("topleft", legend = type, pch = 1, lty = 1, col = cols)
}
}
# library(exactRankTests)
# library(knitr)
# library(xtable)
dim <- c(2,10,30,50,100)
# pop <- 30
populations <- c(10, 30, 50)
for (i in 1:5){
for (mu in 1:3) {
file_name <- paste("sphere_fitness/pop", populations[mu], "dim" , sep = "")
file_name = paste(file_name, dim[i], ".csv" , sep = "")
x <- read.csv(file_name, header = FALSE)
type <- unique(x[,1])
print(type)
# x[,-1] <- log(x[,-1], 10)
# x[,-1] <- x[,-1][sapply(x[,-1],is.numeric)]
# for (j in 1:ncol(x)) {
#   x[,j] <- ifelse(x[,j] == 0)
#     ,NA,x[,j])
# }
# x[,-1] <- log(x[,-1][sapply(x[,-1],is.numeric), 10)
xaxis <- 1:ncol(x[, -1])          # x 軸座標を設定
cols <- c("red", "blue") # PF を赤色、C を青色、G を緑色
# 準備
# print( range(x[,-1][sapply(x[,-1],is.numeric)],na.rm = TRUE))
plot(0, 0, type = "n", xlim = range(xaxis), ylim = range(x[,-1][sapply(x[,-1],is.numeric)],na.rm = TRUE), xlab = "generation number", ylab = "std in fitness")
# 平均値と標準偏差を計算して、書き加える
# type <- unique(x[, 1])             # DEの種類を取得
# type <- x[,1]
# y <- x[c(1,ncol(x))]
# de_with<-y[y[, 1] == type[1], -1]
# de_wo <-y[y[, 1] == type[2], -1]
# shade_with<-y[y[, 1] == type[3], -1]
# shade_wo<-y[y[, 1] == type[4], -1]
# result1 <- wilcox.exact(de_with, de_wo,paired=F)
# result2 <- wilcox.exact(shade_with, shade_wo, paired=F)
# if (result1$p.value > 0.05){
#   print("有意じゃない")
# }
# if (result2$p.value > 0.05){
#   print("有意じゃない関数")
# }
for (k in 1:length(type)) {
m <- apply(x[x[, 1] == type[k], -1], 2, mean)
s <- apply(x[x[, 1] == type[k], -1], 2, sd)
# print(m)
lines(xaxis, m, col = cols[k])
xaxis_n <- c()
m_n <- c()
s_n <- c()
for (j in 1:length(xaxis)) {
if (j %% 100 == 0){
xaxis_n <- append(xaxis_n, xaxis[j])
m_n <- append(m_n, m[j])
s_n <- append(s_n, s[j])
}
}
arrows(xaxis_n, m_n + s_n, xaxis_n, m_n - s_n, angle = 90, length = 0.05, col = cols[k])
arrows(xaxis_n, m_n - s_n, xaxis_n, m_n + s_n, angle = 90, length = 0.05, col = cols[k])
}
eps <- paste("eps/P", populations[mu], "fitD", sep="")
out_put_file_name <- paste(eps, dim[i], ".eps" , sep = "")
# dev.copy2eps(file = "myFigure.eps")
dev.copy2eps(file = out_put_file_name)
# pictex(file = "plot_test.tex")
# グラフに凡例を書き入れる
# legend("topleft", legend = type, pch = 1, lty = 1, col = cols)
}
}
# library(exactRankTests)
# library(knitr)
# library(xtable)
dim <- c(2,10,30,50,100)
# pop <- 30
populations <- c(10, 30, 50)
for (mu in 1:3){
for (i in 1:5) {
file_name <- paste("sphere/pop", populations[mu], "dim" , sep = "")
file_name = paste(file_name, dim[i], ".csv" , sep = "")
x <- read.csv(file_name, header = FALSE)
x[,-1] <- log10(x[,-1])
for (j in 1:ncol(x)) {
x[,j] <- ifelse(is.infinite(x[,j]),NA,x[,j])
}
xaxis <- 1:ncol(x[, -1])          # x 軸座標を設定
cols <- c("red", "blue") # PF を赤色、C を青色、G を緑色
# 準備
plot(0, 0, type = "n", xlim = range(xaxis), ylim = range(x[, -1],na.rm=TRUE),
xlab = "generation number", ylab = "std in distance to centroid")
# 平均値と標準偏差を計算して、書き加える
type <- unique(x[, 1])             # DEの種類を取得
print(type)
# type <- x[,1]
# y <- x[c(1,ncol(x))]
# de_with<-y[y[, 1] == type[1], -1]
# de_wo <-y[y[, 1] == type[2], -1]
# shade_with<-y[y[, 1] == type[3], -1]
# shade_wo<-y[y[, 1] == type[4], -1]
# result1 <- wilcox.exact(de_with, de_wo,paired=F)
# result2 <- wilcox.exact(shade_with, shade_wo, paired=F)
# if (result1$p.value > 0.05){
#   print("有意じゃない")
# }
# if (result2$p.value > 0.05){
#   print("有意じゃない関数")
#   print(i)
# }
for (k in 1:length(type)) {
m <- apply(x[x[, 1] == type[k], -1], 2, mean)
s <- apply(x[x[, 1] == type[k], -1], 2, sd)
lines(xaxis, m, col = cols[k])
xaxis_n <- c()
m_n <- c()
s_n <- c()
for (j in 1:length(xaxis)) {
if (j %% 100 == 0){
xaxis_n <- append(xaxis_n, xaxis[j])
m_n <- append(m_n, m[j])
s_n <- append(s_n, s[j])
}
}
arrows(xaxis_n, m_n + s_n, xaxis_n, m_n - s_n, angle = 90, length = 0.05, col = cols[k])
arrows(xaxis_n, m_n - s_n, xaxis_n, m_n + s_n, angle = 90, length = 0.05, col = cols[k])
}
eps <- paste("eps/P", populations[mu], "D", sep="")
out_put_file_name <- paste(eps, dim[i], ".eps" , sep = "")
# dev.copy2eps(file = "myFigure.eps")
dev.copy2eps(file = out_put_file_name)
# pictex(file = "plot_test.tex")
# グラフに凡例を書き入れる
# legend("topleft", legend = type, pch = 1, lty = 1, col = cols)
}
}
