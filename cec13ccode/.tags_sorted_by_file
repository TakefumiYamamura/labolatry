!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
M	main.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
OShift	main.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
func_flag	main.cpp	/^int ini_flag=0,n_flag,func_flag;$/;"	v
ini_flag	main.cpp	/^int ini_flag=0,n_flag,func_flag;$/;"	v
main	main.cpp	/^int main()$/;"	f
n_flag	main.cpp	/^int ini_flag=0,n_flag,func_flag;$/;"	v
x_bound	main.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
y	main.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
z	main.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
M	main_new.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
OShift	main_new.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
array_all_copy	main_new.cpp	/^void array_all_copy(double** resource_array, double** to_array, int m, int n){$/;"	f
array_copy	main_new.cpp	/^void array_copy(double** resource_array, double** to_array, int len, int i){$/;"	f
crossover_binomial	main_new.cpp	/^void crossover_binomial(double** x, double** v, double** u, int i, int j_rand){$/;"	f
func_flag	main_new.cpp	/^int ini_flag=0,n_flag,func_flag;$/;"	v
generate_mutant_vector	main_new.cpp	/^void generate_mutant_vector(double** x, double** v, int i, int n){$/;"	f
generate_trial_vector	main_new.cpp	/^void generate_trial_vector(double** u, double** v, double** x, double* f, double* p, int i){$/;"	f
ini_flag	main_new.cpp	/^int ini_flag=0,n_flag,func_flag;$/;"	v
main	main_new.cpp	/^int main()$/;"	f
make_random_num	main_new.cpp	/^void make_random_num(int n, int *r1, int *r2, int *r3){$/;"	f
n_flag	main_new.cpp	/^int ini_flag=0,n_flag,func_flag;$/;"	v
x_bound	main_new.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
y	main_new.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
z	main_new.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
MALLOC_ADMIN_REGION_RANGE_TYPE	malloc.h	/^#define MALLOC_ADMIN_REGION_RANGE_TYPE	/;"	d
MALLOC_PTR_IN_USE_RANGE_TYPE	malloc.h	/^#define MALLOC_PTR_IN_USE_RANGE_TYPE	/;"	d
MALLOC_PTR_REGION_RANGE_TYPE	malloc.h	/^#define MALLOC_PTR_REGION_RANGE_TYPE	/;"	d
MALLOC_ZONE_SPECIFIC_FLAGS	malloc.h	/^#define MALLOC_ZONE_SPECIFIC_FLAGS	/;"	d
_MALLOC_MALLOC_H_	malloc.h	/^#define _MALLOC_MALLOC_H_$/;"	d
_malloc_zone_t	malloc.h	/^typedef struct _malloc_zone_t {$/;"	s
address	malloc.h	/^    vm_address_t	address;$/;"	m	struct:__anon1
batch_free	malloc.h	/^    void	(*batch_free)(struct _malloc_zone_t *zone, void **to_be_freed, unsigned num_to_be_freed); \/* frees all the pointers in to_be_freed; note that to_be_freed may be overwritten during the process *\/$/;"	m	struct:_malloc_zone_t
batch_malloc	malloc.h	/^    unsigned	(*batch_malloc)(struct _malloc_zone_t *zone, size_t size, void **results, unsigned num_requested); \/* given a size, returns pointers capable of holding that size; returns the number of pointers allocated (maybe 0 or less than num_requested) *\/$/;"	m	struct:_malloc_zone_t
blocks_in_use	malloc.h	/^    unsigned	blocks_in_use;$/;"	m	struct:malloc_statistics_t
bytes_free	malloc.h	/^    size_t	bytes_free;$/;"	m	struct:mstats
bytes_total	malloc.h	/^    size_t	bytes_total;$/;"	m	struct:mstats
bytes_used	malloc.h	/^    size_t	bytes_used;$/;"	m	struct:mstats
calloc	malloc.h	/^    void 	*(*calloc)(struct _malloc_zone_t *zone, size_t num_items, size_t size); \/* same as malloc, but block returned is set to zero *\/$/;"	m	struct:_malloc_zone_t
check	malloc.h	/^    boolean_t 	(*check)(malloc_zone_t *zone); \/* Consistency checker *\/$/;"	m	struct:malloc_introspection_t
chunks_free	malloc.h	/^    size_t	chunks_free;$/;"	m	struct:mstats
chunks_used	malloc.h	/^    size_t	chunks_used;$/;"	m	struct:mstats
destroy	malloc.h	/^    void 	(*destroy)(struct _malloc_zone_t *zone); \/* zone is destroyed and all memory reclaimed *\/$/;"	m	struct:_malloc_zone_t
disable_discharge_checking	malloc.h	/^    void	(*disable_discharge_checking)(malloc_zone_t *zone);$/;"	m	struct:malloc_introspection_t
discharge	malloc.h	/^    void	(*discharge)(malloc_zone_t *zone, void *memory);$/;"	m	struct:malloc_introspection_t
enable_discharge_checking	malloc.h	/^    boolean_t	(*enable_discharge_checking)(malloc_zone_t *zone);$/;"	m	struct:malloc_introspection_t
enumerate_discharged_pointers	malloc.h	/^    void        (*enumerate_discharged_pointers)(malloc_zone_t *zone, void (^report_discharged)(void *memory, void *info));$/;"	m	struct:malloc_introspection_t
enumerate_unavailable_without_blocks	malloc.h	/^    void	*enumerate_unavailable_without_blocks;   $/;"	m	struct:malloc_introspection_t
enumerator	malloc.h	/^    kern_return_t (*enumerator)(task_t task, void *, unsigned type_mask, vm_address_t zone_address, memory_reader_t reader, vm_range_recorder_t recorder); \/* enumerates all the malloc pointers in use *\/$/;"	m	struct:malloc_introspection_t
force_lock	malloc.h	/^    void	(*force_lock)(malloc_zone_t *zone); \/* Forces locking zone *\/$/;"	m	struct:malloc_introspection_t
force_unlock	malloc.h	/^    void	(*force_unlock)(malloc_zone_t *zone); \/* Forces unlocking zone *\/$/;"	m	struct:malloc_introspection_t
free	malloc.h	/^    void 	(*free)(struct _malloc_zone_t *zone, void *ptr);$/;"	m	struct:_malloc_zone_t
free_definite_size	malloc.h	/^    void (*free_definite_size)(struct _malloc_zone_t *zone, void *ptr, size_t size);$/;"	m	struct:_malloc_zone_t
good_size	malloc.h	/^    size_t	(*good_size)(malloc_zone_t *zone, size_t size);$/;"	m	struct:malloc_introspection_t
introspect	malloc.h	/^    struct malloc_introspection_t	*introspect;$/;"	m	struct:_malloc_zone_t	typeref:struct:_malloc_zone_t::malloc_introspection_t
log	malloc.h	/^    void	(*log)(malloc_zone_t *zone, void *address); \/* Enables logging of activity *\/$/;"	m	struct:malloc_introspection_t
malloc	malloc.h	/^    void 	*(*malloc)(struct _malloc_zone_t *zone, size_t size);$/;"	m	struct:_malloc_zone_t
malloc_introspection_t	malloc.h	/^typedef struct malloc_introspection_t {$/;"	s
malloc_introspection_t	malloc.h	/^} malloc_introspection_t;$/;"	t	typeref:struct:malloc_introspection_t
malloc_statistics_t	malloc.h	/^typedef struct malloc_statistics_t {$/;"	s
malloc_statistics_t	malloc.h	/^} malloc_statistics_t;$/;"	t	typeref:struct:malloc_statistics_t
malloc_zone_t	malloc.h	/^} malloc_zone_t;$/;"	t	typeref:struct:_malloc_zone_t
max_size_in_use	malloc.h	/^    size_t	max_size_in_use;	\/* high water mark of touched memory *\/$/;"	m	struct:malloc_statistics_t
memalign	malloc.h	/^    void *(*memalign)(struct _malloc_zone_t *zone, size_t alignment, size_t size);$/;"	m	struct:_malloc_zone_t
memory_reader_t	malloc.h	/^typedef kern_return_t memory_reader_t(task_t remote_task, vm_address_t remote_address, vm_size_t size, void **local_memory);$/;"	t
mstats	malloc.h	/^struct mstats {$/;"	s
pressure_relief	malloc.h	/^    size_t 	(*pressure_relief)(struct _malloc_zone_t *zone, size_t goal);$/;"	m	struct:_malloc_zone_t
print	malloc.h	/^    void 	(*print)(malloc_zone_t *zone, boolean_t verbose); \/* Prints zone  *\/$/;"	m	struct:malloc_introspection_t
realloc	malloc.h	/^    void 	*(*realloc)(struct _malloc_zone_t *zone, void *ptr, size_t size);$/;"	m	struct:_malloc_zone_t
reserved1	malloc.h	/^    void	*reserved1;	\/* RESERVED FOR CFAllocator DO NOT USE *\/$/;"	m	struct:_malloc_zone_t
reserved2	malloc.h	/^    void	*reserved2;	\/* RESERVED FOR CFAllocator DO NOT USE *\/$/;"	m	struct:_malloc_zone_t
size	malloc.h	/^    size_t 	(*size)(struct _malloc_zone_t *zone, const void *ptr); \/* returns the size of a block or 0 if not in this zone; must be fast, especially for negative answers *\/$/;"	m	struct:_malloc_zone_t
size	malloc.h	/^    vm_size_t		size;$/;"	m	struct:__anon1
size_allocated	malloc.h	/^    size_t	size_allocated;		\/* reserved in memory *\/$/;"	m	struct:malloc_statistics_t
size_in_use	malloc.h	/^    size_t	size_in_use;$/;"	m	struct:malloc_statistics_t
statistics	malloc.h	/^    void	(*statistics)(malloc_zone_t *zone, malloc_statistics_t *stats); \/* Fills statistics *\/$/;"	m	struct:malloc_introspection_t
valloc	malloc.h	/^    void 	*(*valloc)(struct _malloc_zone_t *zone, size_t size); \/* same as malloc, but block returned is set to zero and is guaranteed to be page aligned *\/$/;"	m	struct:_malloc_zone_t
version	malloc.h	/^    unsigned	version;$/;"	m	struct:_malloc_zone_t
vm_range_recorder_t	malloc.h	/^typedef void vm_range_recorder_t(task_t, void *, unsigned type, vm_range_t *, unsigned);$/;"	t
vm_range_t	malloc.h	/^} vm_range_t;$/;"	t	typeref:struct:__anon1
zone_locked	malloc.h	/^    boolean_t   (*zone_locked)(malloc_zone_t *zone); \/* Are any zone locks held *\/$/;"	m	struct:malloc_introspection_t
zone_name	malloc.h	/^    const char	*zone_name;$/;"	m	struct:_malloc_zone_t
E	test_func.cpp	/^#define E /;"	d	file:
EPS	test_func.cpp	/^#define EPS /;"	d	file:
INF	test_func.cpp	/^#define INF /;"	d	file:
PI	test_func.cpp	/^#define PI /;"	d	file:
ackley_func	test_func.cpp	/^void ackley_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Ackley's  *\/$/;"	f
asyfunc	test_func.cpp	/^void asyfunc (double *x, double *xasy, int nx, double beta)$/;"	f
bent_cigar_func	test_func.cpp	/^void bent_cigar_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Bent_Cigar *\/$/;"	f
bi_rastrigin_func	test_func.cpp	/^void bi_rastrigin_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Lunacek Bi_rastrigin Function *\/$/;"	f
cf01	test_func.cpp	/^void cf01 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 1 *\/$/;"	f
cf02	test_func.cpp	/^void cf02 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 2 *\/$/;"	f
cf03	test_func.cpp	/^void cf03 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 3 *\/$/;"	f
cf04	test_func.cpp	/^void cf04 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 4 *\/$/;"	f
cf05	test_func.cpp	/^void cf05 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 4 *\/$/;"	f
cf06	test_func.cpp	/^void cf06 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 6 *\/$/;"	f
cf07	test_func.cpp	/^void cf07 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 7 *\/$/;"	f
cf08	test_func.cpp	/^void cf08 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 8 *\/$/;"	f
cf_cal	test_func.cpp	/^void cf_cal(double *x, double *f, int nx, double *Os,double * delta,double * bias,double * fit, int cf_num)$/;"	f
dif_powers_func	test_func.cpp	/^void dif_powers_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Different Powers *\/$/;"	f
discus_func	test_func.cpp	/^void discus_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Discus *\/$/;"	f
ellips_func	test_func.cpp	/^void ellips_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Ellipsoidal *\/$/;"	f
escaffer6_func	test_func.cpp	/^void escaffer6_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Expanded Scaffer��s F6  *\/$/;"	f
grie_rosen_func	test_func.cpp	/^void grie_rosen_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Griewank-Rosenbrock  *\/$/;"	f
griewank_func	test_func.cpp	/^void griewank_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Griewank's  *\/$/;"	f
katsuura_func	test_func.cpp	/^void katsuura_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Katsuura  *\/$/;"	f
oszfunc	test_func.cpp	/^void oszfunc (double *x, double *xosz, int nx)$/;"	f
rastrigin_func	test_func.cpp	/^void rastrigin_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Rastrigin's  *\/$/;"	f
rosenbrock_func	test_func.cpp	/^void rosenbrock_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Rosenbrock's *\/$/;"	f
rotatefunc	test_func.cpp	/^void rotatefunc (double *x, double *xrot, int nx,double *Mr)$/;"	f
schaffer_F7_func	test_func.cpp	/^void schaffer_F7_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Schwefel's 1.2  *\/$/;"	f
schwefel_func	test_func.cpp	/^void schwefel_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Schwefel's  *\/$/;"	f
shiftfunc	test_func.cpp	/^void shiftfunc (double *x, double *xshift, int nx,double *Os)$/;"	f
sphere_func	test_func.cpp	/^void sphere_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Sphere *\/$/;"	f
step_rastrigin_func	test_func.cpp	/^void step_rastrigin_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Noncontinuous Rastrigin's  *\/$/;"	f
test_func	test_func.cpp	/^void test_func(double *x, double *f, int nx, int mx,int func_num)$/;"	f
weierstrass_func	test_func.cpp	/^void weierstrass_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Weierstrass's  *\/$/;"	f
