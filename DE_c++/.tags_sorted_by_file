!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
main	cauchy.cc	/^int main()$/;"	f
__init__	de.py	/^  def __init__(self):$/;"	m	class:test_function
__init__	de.py	/^  def __init__(self, dim=5):$/;"	m	class:test_rosenbrock_function
__init__	de.py	/^  def __init__(self,$/;"	m	class:differential_evolution_optimizer
differential_evolution_optimizer	de.py	/^class differential_evolution_optimizer(object):$/;"	c
evolve	de.py	/^  def evolve(self):$/;"	m	class:differential_evolution_optimizer
flex	de.py	/^from scitbx.array_family import flex$/;"	i
make_random_population	de.py	/^  def make_random_population(self):$/;"	m	class:differential_evolution_optimizer
optimize	de.py	/^  def optimize(self):$/;"	m	class:differential_evolution_optimizer
print_status	de.py	/^  def print_status(self, mins,means,vector,txt):$/;"	m	class:test_rosenbrock_function
random	de.py	/^from stdlib import random$/;"	i
run	de.py	/^def run():$/;"	f
score_population	de.py	/^  def score_population(self):$/;"	m	class:differential_evolution_optimizer
show_population	de.py	/^  def show_population(self):$/;"	m	class:differential_evolution_optimizer
target	de.py	/^  def target(self, vector):$/;"	m	class:test_function
target	de.py	/^  def target(self, vector):$/;"	m	class:test_rosenbrock_function
test_function	de.py	/^class test_function(object):$/;"	c
test_rosenbrock_function	de.py	/^class test_rosenbrock_function(object):$/;"	c
M	de_main.cc	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
OShift	de_main.cc	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
adjustment	de_main.cc	/^double adjustment(double **x, int i, int func_num){$/;"	f
array_all_copy	de_main.cc	/^void array_all_copy(double** resource_array, double** to_array, int m, int n){$/;"	f
array_copy	de_main.cc	/^void array_copy(double** resource_array, double** to_array, int len, int i){$/;"	f
crossover_binomial	de_main.cc	/^void crossover_binomial(double** x, double** v, double** u, int i, int j_rand){$/;"	f
f	de_main.cc	/^double f[2];$/;"	v
func_flag	de_main.cc	/^int ini_flag=0,n_flag,func_flag;$/;"	v
generate_mutant_vector	de_main.cc	/^void generate_mutant_vector(double** x, double** v, int i, int n){$/;"	f
ini_flag	de_main.cc	/^int ini_flag=0,n_flag,func_flag;$/;"	v
main	de_main.cc	/^int main()$/;"	f
make_random_num	de_main.cc	/^void make_random_num(int n, int *r1, int *r2, int *r3){$/;"	f
n_flag	de_main.cc	/^int ini_flag=0,n_flag,func_flag;$/;"	v
x_bound	de_main.cc	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
y	de_main.cc	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
z	de_main.cc	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
E	func.cpp	/^#define E /;"	d	file:
EPS	func.cpp	/^#define EPS /;"	d	file:
INF	func.cpp	/^#define INF /;"	d	file:
PI	func.cpp	/^#define PI /;"	d	file:
sphere_func	func.cpp	/^double sphere_func (double **x, int t, int n) \/* Sphere *\/$/;"	f
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
main	ran_c_2.cc	/^  int main(){$/;"	f
main	randomc.cc	/^int main(){$/;"	f
nrand	randomc.cc	/^double nrand()$/;"	f
x	randomc.cc	/^double x;$/;"	v
M	shade.cc	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
OShift	shade.cc	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
array_all_copy	shade.cc	/^void array_all_copy(double** to_array, double** resource_array){$/;"	f
array_copy	shade.cc	/^void array_copy(double** to_array, int k ,double** resource_array, int i){$/;"	f
bench_mark	shade.cc	/^double bench_mark(double **x, int i, int func_num){$/;"	f
crossover_binomial	shade.cc	/^void crossover_binomial(double** x, double** v, double** u, int i, int j_rand, double*cr){$/;"	f
dim	shade.cc	/^int dim = 10;$/;"	v
func_flag	shade.cc	/^int ini_flag = 0, n_flag, func_flag;$/;"	v
fv	shade.cc	/^double fv[2];$/;"	v
generate_mutant_vector	shade.cc	/^void generate_mutant_vector(double** x, double** v, int i, double* cr, double* f, double* mcr, double* mf, double** x_sort, vector<double>& archive){$/;"	f
ini_flag	shade.cc	/^int ini_flag = 0, n_flag, func_flag;$/;"	v
m	shade.cc	/^int m = 100;$/;"	v
main	shade.cc	/^int main()$/;"	f
make_random_num	shade.cc	/^void make_random_num(int n, int *r1, int *r2, int archive_size){$/;"	f
make_w	shade.cc	/^void make_w(vector<double>& w, vector<double>& df ){$/;"	f
n_flag	shade.cc	/^int ini_flag = 0, n_flag, func_flag;$/;"	v
randc	shade.cc	/^double randc(double f){$/;"	f
randn	shade.cc	/^double randn(double cr){$/;"	f
randp	shade.cc	/^double randp(){$/;"	f
replace	shade.cc	/^void replace(double **x, int a, int b){$/;"	f
selectxp	shade.cc	/^void selectxp(double ** x, double * xp){$/;"	f
sort_by_func	shade.cc	/^void sort_by_func(double **x, int func_num){$/;"	f
update_mcr	shade.cc	/^void update_mcr(double* mcr, vector<double>& scr, vector<double>& w, int index){$/;"	f
update_mf	shade.cc	/^void update_mf(double* mf, vector<double>& sf, vector<double>& w, int index){$/;"	f
x_bound	shade.cc	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
y	shade.cc	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
z	shade.cc	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
comp	sort_test.cc	/^int comp( const void *c1, const void *c2 )$/;"	f
main	sort_test.cc	/^int main(void)$/;"	f
num	sort_test.cc	/^int num = 100$/;"	v
test_func	sort_test.cc	/^int test_func(double ** x){$/;"	f
M	t.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
OShift	t.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
adjustment	t.cpp	/^double adjustment(double **x, int i, int nx, int mx, int func_num){$/;"	f
array_all_copy	t.cpp	/^void array_all_copy(double** resource_array, double** to_array, int m, int n){$/;"	f
array_copy	t.cpp	/^void array_copy(double** resource_array, double** to_array, int len, int i){$/;"	f
crossover_binomial	t.cpp	/^void crossover_binomial(double** x, double** v, double** u, int i, int j_rand){$/;"	f
f	t.cpp	/^double f[0];$/;"	v
func_flag	t.cpp	/^int ini_flag=0,n_flag,func_flag;$/;"	v
generate_mutant_vector	t.cpp	/^void generate_mutant_vector(double** x, double** v, int i, int n){$/;"	f
ini_flag	t.cpp	/^int ini_flag=0,n_flag,func_flag;$/;"	v
main	t.cpp	/^int main()$/;"	f
make_random_num	t.cpp	/^void make_random_num(int n, int *r1, int *r2, int *r3){$/;"	f
n_flag	t.cpp	/^int ini_flag=0,n_flag,func_flag;$/;"	v
x_bound	t.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
y	t.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
z	t.cpp	/^double *OShift,*M,*y,*z,*x_bound;$/;"	v
E	test_func.cpp	/^#define E /;"	d	file:
EPS	test_func.cpp	/^#define EPS /;"	d	file:
INF	test_func.cpp	/^#define INF /;"	d	file:
PI	test_func.cpp	/^#define PI /;"	d	file:
ackley_func	test_func.cpp	/^void ackley_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Ackley's  *\/$/;"	f
asyfunc	test_func.cpp	/^void asyfunc (double *x, double *xasy, int nx, double beta)$/;"	f
bent_cigar_func	test_func.cpp	/^void bent_cigar_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Bent_Cigar *\/$/;"	f
bi_rastrigin_func	test_func.cpp	/^void bi_rastrigin_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Lunacek Bi_rastrigin Function *\/$/;"	f
cf01	test_func.cpp	/^void cf01 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 1 *\/$/;"	f
cf02	test_func.cpp	/^void cf02 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 2 *\/$/;"	f
cf03	test_func.cpp	/^void cf03 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 3 *\/$/;"	f
cf04	test_func.cpp	/^void cf04 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 4 *\/$/;"	f
cf05	test_func.cpp	/^void cf05 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 4 *\/$/;"	f
cf06	test_func.cpp	/^void cf06 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 6 *\/$/;"	f
cf07	test_func.cpp	/^void cf07 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 7 *\/$/;"	f
cf08	test_func.cpp	/^void cf08 (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Composition Function 8 *\/$/;"	f
cf_cal	test_func.cpp	/^void cf_cal(double *x, double *f, int nx, double *Os,double * delta,double * bias,double * fit, int cf_num)$/;"	f
dif_powers_func	test_func.cpp	/^void dif_powers_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Different Powers *\/$/;"	f
discus_func	test_func.cpp	/^void discus_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Discus *\/$/;"	f
ellips_func	test_func.cpp	/^void ellips_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Ellipsoidal *\/$/;"	f
escaffer6_func	test_func.cpp	/^void escaffer6_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Expanded Scaffer¡¯s F6  *\/$/;"	f
grie_rosen_func	test_func.cpp	/^void grie_rosen_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Griewank-Rosenbrock  *\/$/;"	f
griewank_func	test_func.cpp	/^void griewank_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Griewank's  *\/$/;"	f
katsuura_func	test_func.cpp	/^void katsuura_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Katsuura  *\/$/;"	f
oszfunc	test_func.cpp	/^void oszfunc (double *x, double *xosz, int nx)$/;"	f
rastrigin_func	test_func.cpp	/^void rastrigin_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Rastrigin's  *\/$/;"	f
rosenbrock_func	test_func.cpp	/^void rosenbrock_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Rosenbrock's *\/$/;"	f
rotatefunc	test_func.cpp	/^void rotatefunc (double *x, double *xrot, int nx,double *Mr)$/;"	f
schaffer_F7_func	test_func.cpp	/^void schaffer_F7_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Schwefel's 1.2  *\/$/;"	f
schwefel_func	test_func.cpp	/^void schwefel_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Schwefel's  *\/$/;"	f
shiftfunc	test_func.cpp	/^void shiftfunc (double *x, double *xshift, int nx,double *Os)$/;"	f
sphere_func	test_func.cpp	/^void sphere_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Sphere *\/$/;"	f
step_rastrigin_func	test_func.cpp	/^void step_rastrigin_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Noncontinuous Rastrigin's  *\/$/;"	f
test_func	test_func.cpp	/^void test_func(double *x, double *f, int nx, int mx,int func_num)$/;"	f
weierstrass_func	test_func.cpp	/^void weierstrass_func (double *x, double *f, int nx, double *Os,double *Mr,int r_flag) \/* Weierstrass's  *\/$/;"	f
